#!/bin/bash

cmd=$1
count=0
history=""
statement=""

### $1: 表示文字列
### $1を表示し、statementを$1として更新する
function cmdline() {
  printf '\r%s' "                                                                      " # 文字クリア
  printf '\r%s' "" # カーソル先頭
  # printf '\r%s' "\033[34m$cmd\033[00m$1"
  printf "\033[34m[ $cmd ] >> \033[00m$1"
  statement=$1
}

cmdline

while IFS= read -r -n1 -s char; do # １文字ずつ入力を読む
  if [[ $char == $'\x1b' ]]; then # arrow key
    read -r -n2 -s rest
    char+="$rest"
  elif [ "$char" = "" ] ; then # enter  (blank)
    char="enter"
  elif [ "$char" = "" ] ; then # backspace  (zero with non joiner)
    char="backspace"
  elif [ "$char" = " " ] ; then # space
    char="space"
  fi

  case $char in

    $'\x1b\x5b\x41' ) # ↑ # read key; echo "$key" | hexdump で確認した
      # 一つ上のhistoryを表示
      (( count++ ))
      cmdline "`echo -ne $history | tail -n $count | head -n1`" ;;

    $'\x1b\x5b\x42' ) # ↓
      if [ $count -gt 0 ] ; then
        (( count-- ))
        cmdline
      fi
      cmdline "`echo -ne $history | tail -n $count | head -n1`" ;;

    $'\x1b\x5b\x43' ) ;; # →

    $'\x1b\x5b\x44' ) ;; # ←

    enter )
      echo ""
      line=$cmd" "$statement
      `echo $line`
      count=0
      history=$history$statement"\n"
      cmdline ;;

    backspace )
      len=$(( ${#statement} - 1 ))
      if [ $len -ge 1 ] ; then
        cmdline "`echo -ne $statement | cut -c 1-$len`"
      elif [ $len -eq 0 ] ; then
        cmdline
      fi ;;

    space )
      cmdline "$statement " ;;

    * )
      cmdline "$statement$char" ;;
  esac
done
